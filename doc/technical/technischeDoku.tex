\documentclass[a4paper,12pt]{scrartcl}
% \setcounter{secnumdepth}{3}
% \setcounter{tocdepth}{5}

% \makeatletter
% \renewcommand\section{\newpage\@startsection {section}{1}{\z@}%
%                                    {-3.5ex \@plus -1ex \@minus -.2ex}%
%                                    {2.3ex \@plus.2ex}%
%                                    {\normalfont\Large\bfseries}} 
% \renewcommand\paragraph{\@startsection{paragraph}{4}{\z@}%
%                                      {-3.25ex\@plus -1ex \@minus -.2ex}%
%                                      {0.0001pt \@plus .2ex}%
%                                      {\normalfont\normalsize\bfseries}}
% \renewcommand\subparagraph{\@startsection{subparagraph}{5}{\z@}%
%                                      {-3.25ex\@plus -1ex \@minus -.2ex}%
%                                      {0.0001pt \@plus .2ex}%
%                                      {\normalfont\normalsize\bfseries}}
% \makeatother

\newcommand\doctype{Technische Dokumentation}
\newcommand\supervisor{Prof. Dr. phil. Hugo M. Kehr}
\newcommand\advisor{Dipl. Psych. Stefan Engeser}
\newcommand\deliverydate{4. M{\"a}rz 2011}

\newcommand*{\code}[1]{\texttt{#1}}% style for code insertions

\usepackage[T1]{fontenc}
\usepackage{lmodern}


% \usepackage{pstricks}
% \usepackage{pst-plot}
% \usepackage{auto-pst-pdf}

\usepackage{bibgerm}
\usepackage[hang,flushmargin]{footmisc}
\usepackage[printonlyused]{acronym}
\usepackage{url}
\usepackage[latin1]{inputenc}
\usepackage{graphicx}
\usepackage[hang,small,bf]{caption}
\usepackage{styles/tumlogo}
\usepackage{setspace}
\usepackage[german,english]{babel}
\usepackage{needspace}
\usepackage{fancyhdr}
\pagestyle{fancy}
\headheight 35pt
\lhead{\nouppercase{\leftmark}}
\rhead{\includegraphics[height=0.5cm]{styles/info.pdf}}


% \selectlanguage{english}

% \usepackage{hyperref} % sorgt f�r f�r Hyperlinks in PDF-Dokumenten
\usepackage[plainpages=false,pdfpagelabels, bookmarks=true]{hyperref}                                             %. hyper-references for ps2pdf 
% \usepackage[ocgcolorlinks]{hyperref}     % sorgt f�r farbige f�r Hyperlinks, die beim Ausdruck schwarz sind
\hypersetup{
    breaklinks=true
    unicode=false,          % non-Latin characters in Acrobat's bookmarks
    pdftoolbar=true,        % show Acrobat's toolbar?
    pdfmenubar=true,        % show Acrobat's menu?
    pdffitwindow=true,      % page fit to window when opened
    pdftitle={},    % title
    pdfauthor={},     % author
    pdfsubject={},   % subject of the document
    pdfnewwindow=true,      % links in new window
    pdfkeywords={}, % list of keywords
    pdfstartview={FitH},
    colorlinks=true,       % false: boxed links; true: colored links
%     linkcolor=red,          % color of internal links
%     citecolor=green,        % color of links to bibliography
%     filecolor=magenta,      % color of file links
%     urlcolor=cyan           % color of external links
    linkcolor=black,          % color of internal links
    citecolor=black,        % color of links to bibliography
    filecolor=black,      % color of file links
    urlcolor=black           % color of external links
}

\makeatletter
\g@addto@macro\UrlBreaks{\do\a\do\b\do\c\do\d\do\e\do\f\do\g\do\h\do\i%
\do\j\do\k\do\l\do\m\do\n\do\o\do\p\do\q\do\r\do\s\do\t\do\u\do\v\do\w%
\do\x\do\y\do\z\do\&\do\1\do\2\do\3\do\4\do\5\do\6\do\7\do\8\do\9\do\0}
%\def\do@url@hyp{\do\-}
\g@addto@macro\UrlSpecials{\do\/{\mbox{\UrlFont/}\hskip 0pt plus 1pt}}
\makeatother

\usepackage{cite}

\widowpenalty=10000
\clubpenalty=10000

\parindent 0pt % keine Absatzeinr�ckung
\parskip 6pt % aber danach ein gewisser Abstand

\graphicspath{{graphics/}}

% \sloppy

\input{hyphenation} % in dieses File kommen W�rter die Latex nicht richtig trennt

\begin{document}

\include{cover}
\include{titlepage}
% \include{disclaimer}
% 
% \pagenumbering{roman}
% \thispagestyle{plain}
% 
% 
% \selectlanguage{english}
% \thispagestyle{plain}
% \begin{abstract}
% \noindent english abstract
% \end{abstract}
% \clearpage

\selectlanguage{german}
% \begin{abstract}
% \noindent Deutsche Kurzfassung
% \end{abstract}
% \clearpage


\tableofcontents
\clearpage

\pagenumbering{arabic}


\clearpage


\section{Funktionale Anforderungen}
Der Zustand des "`Flow"' ist ein psychologisches Ph�nomen, das bei diversen verschiedenen
T�tigkeiten zu beobachten ist. Computerspiele z�hlen zu diesen T�tigkeiten, da sie die
grundlegenden Anforderungen zur Generierung von Flow erf�llen: Der Spieler muss aktiv
sein und einer gewissen Herausforderung gegen�berstehen.\newline
In diesem Projekt soll also zun�chst einmal ein Spiel entwickelt werden, das den Spieler
potentiell in einen Zustand des Flow bringt, oder, so gewollt, in einen Zustand des "`Nicht-
Flow"'.

Als Spielkonzept wurde ein simples Setting gew�hlt: Der Spieler steuert ein Raumschiff
und muss dabei Hindernissen ausweichen und Boni aufsammeln, die mit variabler
Geschwindigkeit auf ihn zukommen. Anhand der Geschwindigkeit l�sst sich hierbei der
Schwierigkeitsgrad regulieren, um so gezielt Unterforderung, �berforderung oder ideale
Anforderungen schaffen zu k�nnen.

Zur Navigation im Spiel ist es n�tig, zun�chst ein Hauptmen� zu integrieren, in dem man
w�hlen kann, ob man eine Runde beginnen, die Highscores einsehen, die
pers�nlichen Einstellungen �ndern oder die Credits ansehen m�chte.\newline
Bei neuen Spielern wird zun�chst ein Pers�nlichkeitsprofil angelegt, in dem der Spieler
mithilfe eines Fragebogens gewisse pers�nliche Charakteristika angibt, die zur Auswertung
der erhobenen Daten hilfreich sind.\newline
Ist dies geschehen, kann ein Spiel beginnen. Dieses ist aufgeteilt in mehrere Runden, in
denen zun�chst die "`Tagesform"', also die Leistungsf�higkeit f�r diese Sitzung gemessen
wird. Dies erm�glicht, trotz Lerneffekten oder anderen Einfl�ssen, wie etwa M�digkeit oder
mangelnder Konzentration, in jeder Situation die idealen Anforderungen zu
generieren.\newline
Daraufhin folgen drei Runden, in denen sich verschiedene
Anforderungsstufen abwechseln. Um die Rahmenbedingungen f�r alle Spieler gleich zu halten, hat jede Runde eine fixe
Dauer.

%\usepackage{graphics} is needed for \includegraphics
\begin{figure}[htp]
\begin{center}
  \includegraphics[width=\textwidth]{SpielablaufClient}
  \caption{Clientseitiger Spielablauf}
  \label{fig:ClientSpielablauf}
\end{center}
\end{figure} 

Das ganze Spiel ist, um etwas Atmosph�re zu erzeugen, in eine Rahmengeschichte
eingebettet, die den Spieler in ein Science-Fiction-Szenario hineinversetzt und ihm vor jeder
Runde eine Aufgabe gibt, die er zu erf�llen hat und ihm am Ende der Runde �ber seine
Erfolge berichtet.\newline
Zus�tzlich wird das Befinden in einer Art "`Rennen"' durch ein schnelles, futuristisch
erscheinendes Musikst�ck unterst�tzt, das w�hrend den Runden abgespielt wird und
speziell hierf�r komponiert wurde.

Um anhand hiervon nun festzustellen, ob ein Spieler Flow erf�hrt, muss eine Methode
gew�hlt werden, um dies zu messen.\newline
Das Mittel der Wahl sind hier Teile der Frageb�gen der von Rheinberg et. al. \cite{Rheinberg2003}
entwickelten FKS\footnote{Flow-Kurzskala}, die zwischen den Spielrunden eingeblendet
werden, sowie weitere Fragen zur Anforderungspassung, um das subjektive Empfinden der angepassten Schwierigkeit
�berpr�fen zu k�nnen. Die Beantwortung dieser Fragen erfolgt durch einen stufenlos
anpassbaren Schieberegler, der zwischen zwei gegens�tzlichen Adjektiven nach
Belieben eingestellt werden kann. Ein Lerneffekt beim Beantworten der Fragen oder eine
Automatisierung ebendessen wird verhindert, indem die Fragen in randomisierter
Reihenfolge erscheinen. Au�erdem wird die Dauer der Beantwortung eines jeden
Fragebogens gemessen, was R�ckschl�sse darauf zul�sst, ob der Spieler nur zuf�llig etwas angeklickt, oder die Fragen tats�chlich
gelesen und gewissenhaft beantwortet hat.

Als Plattform f�r das Spiel wurde das soziale Netzwerk Facebook\footnote{\url{http://www.facebook.com}} gew�hlt, das die
Integration von vielf�ltigen Anwendungen erlaubt. Mit Facebook lassen sich vielerlei Daten,
die der Spieler auf seinem Profil ohnehin angegeben hat, wie etwa Alter, Geschlecht und
Herkunft, nutzen. Diese Daten k�nnen dann automatisiert und ohne zus�tzliche Angaben
erfasst werden und in die Auswertung einflie�en.\newline
Au�erdem ist es hier m�glich,die Leistungen verschiedener Teilnehmer zu vergleichen
und in einer Highscore darzustellen. Das erlaubt die Untersuchung von Unterschieden der
Leistung von individuell und sozial motivierten Spielern.

Zuletzt wurde eine einfache und umfassende M�glichkeit zur Auswertung der erhobenen Daten gefordert.
Dies lie� sich durch eine direkte Einspeisung in eine relationale Datenbank realisieren und bietet den Vorteil, dass die Daten elektronisch und delokalisiert vorliegen, was den Zugriff �ber das Internet erm�glicht. Hierf�r steht eine webbasierte Oberfl�che zur Verf�gung. Zudem l�sst sich die Datenbank im SPSS-Format\footnote{Datenformat der Statistiksoftware SPSS Statistics.} exportieren.

\section{Nicht-Funktionale Anforderungen}
Um gleiche Rahmenbedingungen und damit eine Vergleichbarkeit zwischen verschiedenen
Spielern und Spielen nicht von vornherein zu verhindern, muss der Spielablauf in
eine m�glichst kontrollierte Umgebung eingebettet werden. Das bedeutet, dass sich
verschiedene Spiele nicht zu stark voneinander unterscheiden d�rfen. Ein kritischer Punkt
hierf�r ist die Dauer einer Runde. Es steht zu bef�rchten, dass Spieler trotz gleichem
Schwierigkeitsgrad signifikant unterschiedliche Erlebnisse berichten, wenn sich die
Spieldauer in gro�em Ma�e unterscheidet. Daher wurde f�r jede Runde eine fixe Spieldauer
von 120 Sekunden festgelegt. Diese Dauer l�sst sich auch nicht durch ein "`verlieren"'
oder "`sterben"', wie in anderen Spielen �blich verk�rzen. Man muss in diesem Spiel zwar
Hindernissen ausweichen, diese f�hren aber nie zum Spieltod, sondern immer nur zu einer
Verringerung der Endpunktzahl. Diese Endpunktzahl �bt als Ma� zur Leistungsmessung f�r
den Spieler einen Anreiz f�r hohe Leistung und damit Anstrengung aus. Daher ist es
sinnig, dass der Spieler neben dem zwanghaften Ausweichen von Hindernissen auch noch
eine Anforderung darin hat, gleichzeitig m�glichst viele Bonuspunkte zu sammeln.

Obwohl es sich hierbei um ein psychologisches Experiment handelt, ist es w�nschenswert,
dass der Spieler nicht das Gef�hl hat, in einem Labor an einer Datenerhebung
teilzunehmen, sondern vielmehr ein Spiel spielt, um sich die Zeit zu vertreiben.
Daraus resultieren die oben genannten Anforderungen, das Spiel mit
Rahmengeschichte und Musik auszustatten, da dies von einem Spiel erwartet wird und
ein Fehlen solcher Details zu einem verf�lschten Empfinden f�hren k�nnte. Ebenso
geh�rt dazu, dass die Frageb�gen m�glichst gut ins Spiel eingebettet werden und ihre
Beantwortung durch eine Rahmengeschichte eingepasst wird. M�ssten die Frageb�gen
extern bearbeitet werden, etwa per Papier oder auf einer separaten Webseite, so w�re es
unvermeidlich, dass der Spieler sich mehr als Proband empfindet.

Ziel des Projekts ist au�erdem, m�glichst viele Datens�tze zu erheben, also m�glichst viele
Menschen zu erreichen. Daf�r muss das Spiel allerdings einige Anforderungen erf�llen
und nicht zu hohe H�rden an den Benutzer stellen. Das bedeutet zun�chst eine m�glichst
einfache Bedienbarkeit. Angestrebt waren lediglich vier Tasten, n�mlich die Pfeiltasten,
die ausreichend sind, das Raumschiff nach oben, unten, links und rechts zu steuern. Ebenso
dazu geh�rt es, das Spiel m�glichst kurzweilig zu gestalten. Ein Spiel (bestehend ja aus
vier Runden) sollte weniger als 15 Minuten dauern, um der kurzlebigen Internetkultur zu
entsprechen. Im Internet wird oft kurz "`zwischendurch"' oder beim Warten gespielt und eine
l�ngere Dauer w�rde das Spiel hierf�r komplett ausschlie�en. Au�erdem ist es wichtig, den
Anforderungen der verbreitetsten Betriebssysteme Windows, MacOS X und Linux, gerecht zu werden.
Teile der potentiellen Teilnehmerschaft wegen ihres
Betriebssystems ausschlie�en zu m�ssen, sollte vermieden werden. Ebenso gibt es keinen
Grund, das Projekt auf den deutschen Raum zu beschr�nken. Eine Sprachunterst�tzung
von Englisch und Deutsch soll die Anzahl der potentiellen Teilnehmer noch einmal
signifikant erh�hen. Dazu wurden die Standards der in der Informatik so genannten "`I18N"'
(kurz f�r Internationalisierung) eingehalten. Teil dessen ist, dass Programmteile, die sich
bei unterschiedlichen Sprachversionen unterscheiden, nicht im Quellcode stehen, sondern
einfach durch den Austausch von bestimmten Dateien ersetzt werden k�nnen. Dies
erm�glicht die Erweiterung auf andere Sprachr�ume, ohne das eigentliche Programm zu
�ndern.

\section{Architektur}
\subsection{Client-Server}
Die grundlegende Architektur des Spiels ist Client-Server-basiert, wobei ein auf
Facebook angezeigtes Applet den Client und ein auf einem separaten Server laufender
Webcontainer den Server darstellen. Die Kommunikation zwischen Client und Server erfolgt
ausschlie�lich �ber HTTP\footnote{Hypertext Transfer Protocol -- Protokoll zur
�bertragung von Daten �ber ein Netzwerk, haupts�chlich f�r die �bermittlung
von Webseiten eingesetzt.}. Programmcode f�r Funktionalit�ten, die spezifisch
f�r Client (Benutzerschnittstelle, 3D-Umgebung, Facebook-Anbindung) und Server (Datenbank-Anbindung, Programmlogik) sind, ist voneinander unabh�ngig, lediglich der Programmcode f�r das gemeinsam genutzte Datenmodell ist beiden Seiten bekannt. Dies entspricht der �blichen Praxis, reduziert unerw�nschte Seiteneffekte und ergibt eine klare Trennung der
Verantwortlichkeiten.

\clearpage

\subsection{Datenmodell}

\begin{figure}[htp]
\begin{center}
  \includegraphics[width=\textwidth]{uml}
  \caption{Datenmodell in UML}
  \label{fig:uml}
\end{center}
\end{figure} 

\clearpage

\section{Technologien}
Um den Entwicklungsaufwand f�r ein plattform�bergreifendes Spiel m�glichst gering
zu halten, haben wir uns entschieden, dass Spiel in Java umzusetzen, da es f�r alle
verbreiteten Betriebssysteme verf�gbar ist und eine solide Bibliothek an Funktionen mit sich
bringt.

Serverseitig l�uft eine Webanwendung auf Basis von Struts 2\footnote{Framework zur Entwicklung von Webapplikationen, \url{http://struts.apache.org}} und Servlets/JSPs, die
�ber EclipseLink als JPA\footnote{Java Persistence API, eine Schnittstelle um
Objekt-Graphen in relationale Datenbanksysteme
abzubilden.}-Provider mit einer Datenbank kommuniziert, um Spieldaten zu speichern. F�r die Kommunikation mit dem clientseitigen Spiel wird ein auf serialisierte Java-Objekte aufbauender RPC\footnote{Remote Procedure Call, das Aufrufen von
Programmcode auf einem anderen Computersystem.}-Mechanismus �ber HTTP angewandt.

Clientseitig l�uft ein Applet\footnote{Im Webbrowser laufendes Java-Programm}, dass �ber Java3D die 3D-Umgebung und �ber Swing\footnote{Bibliothek zur Grafikausgabe unter Java} die Benutzerschnittstelle anzeigt. Beide Bibliotheken abstrahieren die zugrundelegenden Techniken stark, was eine komfortable Entwicklung komplexer 3D-Umgebungen und Benutzerschnittstellen erm�glicht. F�r die Anbindung an Facebook wird im Applet eine weitere Bibliothek verwendet, die aufgrund von Sicherheitseinschr�nkungen (Same Origin Policy) alle Aufrufe an das Facebook API �ber den Spielserver abwickelt.

\section{Implementierung}
\subsection{Baselinemessung und adaptive Schwierigkeit}
F�r die Erzeugung und Messung von Flow bzw. Unter- und �berforderung passt sich das
Spiel dem Spieler an. Dazu wird zu Beginn einer jeden Sitzung
zun�chst die Baseline bestimmt. Diese Baseline stellt die vermutete ideale
Anforderung an einen Spieler dar. Alle weiteren Runden werden im Verh�ltnis zur Baseline
im Schwierigkeitsgrad variiert.

In diesem Kapitel wird zun�chst kurz die Messung der Baseline erl�utert und
Schwierigkeiten die dabei auftreten k�nnen. Anschlie�end wird gezeigt, wie die
Geschwindigkeit der �brigen Runden aus der Baseline errechnet werden kann.

Bei der Baselinemessung soll erreicht werden, dass man die ideale Spielschwierigkeit f�r
einen Spieler ermittelt. Diese besteht prinzipiell aus den drei Komponenten Geschwindigkeit,
Verh�ltnis von Diamanten zu Asteroiden und Abstand zwischen den Asteroiden. Der
Einfachheit halber wird in unserem Experiment ausschlie�lich die Geschwindigkeit variiert,
eine Anpassungen der beiden anderen Parameter k�nnte aber analog erfolgen.

Die Passung soll ermittelt werden, indem zun�chst alle auf der gleichen Geschwindigkeit
starten. Nach und nach wird die Geschwindigkeit erh�ht, bis der Spieler nicht mehr mithalten
kann. An diesem Punkt wird wieder abgesenkt, bis es anscheinend deutlich zu einfach
wird. Dies wird in mehreren Iterationen �ber zwei Minuten hinweg wiederholt, wobei
der Ausschlag nach und nach kleiner wird und sich auf einer bestimmten Schwierigkeit
einpendelt. Die Baseline ist dann die Schwierigkeit oberhalb derer sich der
Spieler 50\% der Zeit halten konnte. Dieses Verhalten f�hrt zu dem in Abbildung \ref{fig:Baseline} dargestellten typischen
Verlauf.

%\usepackage{graphics} is needed for \includegraphics
\begin{figure}[htp]
\begin{center}
  \includegraphics[width=0.6\textwidth]{Baseline.png}
  \caption[Baselinemessungsverlauf]{Baselinemessung Verlauf (blaue Linie),
  gemessene Baseline (rote Linie)}
  \label{fig:Baseline}
\end{center}
\end{figure} 

Als erstes muss also zun�chst bestimmt werden, ob die Schwierigkeit zu einem gegebenen
Moment zu gro� oder zu klein ist. Dazu speichert die Klasse \texttt{Trend}, zu wieviel Prozent der Spieler mit einem bestimmten Objekt (Diamant oder Asteroid) kollidiert ist bzw. ihm ausgewichen ist. Es wird jeweils ein lang-, mittel- und kurzfristiger Trend ermittelt, sodass die Entscheidung nicht nur anhand der letzten Aktionen des Spelers getroffen werden.
Der langfristige Trend bezieht sich hierbei auf die letzten 30 passierenden Objekte.
Mittelfristig sind es die letzten 10 und f�r den kurzfristigen Trend werden nur die letzten 3 beachtet.

Beispiel: Es sind 10 Objekte in der folgenden Reihenfolge vorbeigeflogen, wobei ein (K)
bedeutet, dass der Spieler mit ihnen kollidiert ist:
\begin{enumerate}
\item Asteroid
\item Asteroid
\item Diamant (K)
\item Asteroid
\item Diamant (K)
\item Diamant
\item Diamant (K)
\item Asteroid (K)
\item Asteroid (K)
\item Diamant
\end{enumerate}
Dann ist der kurzfristige Trend, dass der Spieler mit 2 Asteroiden kollidiert
ist (Rate 100\%) und keinen Diamanten gesammelt hat (0\%), was eine �berforderung vermuten l�sst.
Der mittelfristige Trend ist mit 2 Asteroiden (40\%) und 4 Diamanten (80\%)
dagegen deutlich ausgewogener.

Aus dieser Information muss nun abgesch�tzt werden, wann das Spiel langsamer und wann
es schneller werden sollte. Hierf�r wurden mehrere verschiedene Methoden getestet. Im
Folgenden wird lediglich die beschrieben, die tats�chlich verwendet wurde, da sie sich als
am exaktesten herausgestellt hat.

Bis der Spieler mindestens zehn Objekte passiert hat wird die Geschwindigkeit stetig
angehoben, da man bis zu diesem Moment noch nicht genug Daten hat, um
eine individualisierte Entscheidung zu treffen. Danach richtet sich die Anpassung der
Geschwindigkeit nach den gemessenen Trends. Kollidiert der Spieler mit einem Asteroiden
oder schafft er es nur 1/3 der Diamanten aufzusammmeln so wird kurz abgebremst.
Sammelt er dagegen erfolgreich mehr als 2/3 der Diamanten, so wird sehr stark
beschleunigt. Sammelt er mittelfristig zumindest noch mehr als 1/3 der
passierenden Diamanten so wird leicht beschleunigt. Wenn keine dieser Bedingungen zutrifft,
so bleibt alles gleich schnell. Dieses Verhalten wird von der \code{FunctionStrategy2} gesteuert.

Nun bleibt die Frage, wie stark beschleunigt oder gebremst werden soll. Am einfachsten
erscheint es unabh�ngig von der aktuellen Geschwindigkeit, diese um einen fixen Betrag
zu erh�hen oder zu reduzieren. Als dies mit Spielern getestet wurde haben wir jedoch
festgestelt, dass bei h�herer Ausgangsgeschwindigkeit schon kleine Beschleunigungen
sich sehr drastisch anf�hlen, w�hrend bei niedrigeren Geschwindigkeiten die
Geschwindigkeitserh�hung gr��er sein muss, um �berhaupt wahrgenommen zu werden.

Um m�glichst einfach mehrere verschiedene Modelle testen zu k�nnen wird deshalb der
Betrag der Erh�hung aus einer Funktion ermittelt. Die Funktion bildet eine Position auf
eine Geschwindigkeit ab. Zu Beginn einer Baselinerunde startet der Spieler an Position
0. Soll das Spiel schneller werden, so wird die Position erh�ht, anders gesenkt. Die neue
Geschwindigkeit ergibt sich aus dem Wert der Funktion an der neuen Position.

Am besten hat sich die Funktion $\max(240 \tanh(\frac{x}{5000})+60,
30)$ erwiesen. Sie ist monoton steigend und bewegt sich zwischen dem niedrigsten
Wert (30) und n�hert sich langsam an 300. Bei dieser Funktion sind die Anpassungen 
bei langsamen Geschwindigkeiten deutlicher sind als bei hohen Geschwindigkeiten.

%\usepackage{graphics} is needed for \includegraphics
\begin{figure}[htp]
\begin{center}
  \includegraphics[width=1.0\textwidth]{BaselineFunktion.pdf}
  \caption[Grundlagenfunktion Baselinemessung]{Funktion die als Grundlage f�r
  die Baselinemessung verwendet wird.}
  \label{fig:BaselineFunktion}
\end{center}
\end{figure} 

Jede �nderung der Geschwindigkeit wird im \code{SpeedChangeBehavior} angesto�en. Bei der
Baselinemessung merkt sich das Spiel jeden Wert und bestimmt zum Schluss die Baseline
aus dem Median dieser Werte.

Ausgehend von der Baseline werden die Geschwindigkeitenf�r die folgenden drei Runden
folgenderma�en bestimmt:\\
Stufe 1 - Unterforderung: $(Baseline - 60 + Baseline\cdot0,7)/2$\\
Stufe 2 - Passung: $(Baseline - 0 + Baseline\cdot1)/2$\\
Stufe 3 - �berforderung: $(Baseline + 60 + Baseline\cdot1,13)/2$\\

Im Quellcode wurden diese wiederum durch Funktionen dargestellt. Bei der
\code{ConstantFunction} bleibt die Geschwindigkeit �ber eine Runde hinweg konstant.
Die Anfangsgeschwindigkeit wird einmalig anhand der Baseline errechnet. F�r die
kontinuierliche Bedingung wird eine passende \code{LinearFunction} ben�tigt. Hierbei muss
sich nicht nur der Schnittpunkt mit der y-Achse �ndern sondern auch die Steigung,
damit kein Sprung in der Geschwindigkeit zwischen den drei Runden besteht. Also
wird zun�chst die Steigung passend zur Baseline ermittelt. Daraufhin muss noch
die Geschwindigkeit zum Beginn der Runde ermittelt werden. Diese liegt so, dass
die mittlere Geschwindigkeit identisch w�re, zu der bei einer Runde mit konstanter
Geschwindigkeit (Abbildung \ref{fig:SessionTypen}).

%\usepackage{graphics} is needed for \includegraphics
\begin{figure}[htp]
\begin{center}
  \includegraphics[width=10cm]{SessionTypen.pdf}
  \caption[Vergleich der Geschwindigkeitsfunktionen]{Zeigt die Relation zwischen
  Baseline, konstanter und linearer Funktion. Die konstante Funktion hat innerhalb einer Runde (gestrichelte Linie) stets die gleiche
mittlere Geschwindigkeit wie die lineare Funktion.}
  \label{fig:SessionTypen}
\end{center}
\end{figure}

\subsection{Men�system im Spiel}
Zur schnellen Entwicklung der Benutzerschnittstellen wurde auf den
vollst�ndigen Eigenbau eines Men�systems verzichtet und stattdessen eine d�nne Kompatibilit�tsschicht
eingef�hrt, die es erm�glicht, die bestehende Swing-Bibliothek von Java f�r die
Benutzerschnittstelle des Spiels �ber die 3D-Umgebung zu legen. Dadurch kann die
Benutzerschnittstelle wie gewohnt entwickelt und separat getestet werden, ohne auf die
besonderen Herausforderungen R�cksicht nehmen zu m�ssen, die es mit sich bringt, wenn
man grafische Elemente wie Buttons, Radio-/Checkboxen und Scrollleisten in einer 3D-
Umgebung verwenden m�chte.

Die hierf�r entwickelte Kompatibilit�tsschicht (\texttt{OffscreenJPanel})
zeichnet alle Swing-Komponenten in ein transparentes Bild, dass dann �ber die 3D-Umgebung des Spiels
gelegt wird. Alle Maus- und Tastatureingaben auf diesem Bild werden abgefangen und an
die eigentlichen Swing-Komponenten weitergeleitet. W�hrend der Spieler das Raumschiff
steuert, wird das komplette Swing-System ausgeblendet, was die Performance des Spiels
verbessert.

Um den zugrundeliegenden Ablauf des Spiels intuitiv programmieren zu k�nnen, wurde
aufbauend auf die o.g. Kompatibilit�tsschicht ein Men�system (\texttt{GameMenu}, \texttt{MenuScreen} und das Package \texttt{ui.screen}) entwickelt, dass die von Spielen typische
Abfolge von "`Bildschirmen"' erleichtert, zwischen denen der Spieler sich auf vordefinierten Pfaden
bewegen kann.

\subsection{Persistenz von Benutzereinstellungen}
Das Spiel bietet die M�glichkeit, die Sounds an- und abzustellen sowie die Steuerung zu
invertieren, so dass die Auf/Ab-Pfeile sich wahlweise wie bei einem Flugzeugsimulator oder
Rennspiel verhalten. Um diese Einstellungen persistent zu halten, verwendet das Applet die
LiveConnect-Funktionalit�t moderner Webbrowser, mit denen es Javascript-Code im das
Applet umgebenden HTML-Dokument aufrufen kann. Dort werden die Einstellungen dann
als Cookie abgelegt und beim wiederholten Starten des Spiels automatisch ausgelesen.

\subsection{RPC-Eigenbau �ber HTTP mit Java Objekt-Serialisierung}
F�r die Kommunikation des Spielapplets mit dem
Spielserver wurde ein RPC-Mecha\-nismus entwickelt, der
sowohl einfach zu verwenden ist als auch problemlos �ber das Internet funktioniert. Als Grundlage dient die HTTP-Verbindung zum Spielserver, �ber die bereits
das Spiel selbst bestehend aus Programmcode, Grafiken, Sounds, usw. geladen wird.
Will das Spiel nun im Ablauf weitere Daten vom Spielserver empfangen oder an diesen
senden, werden diese als Java-Objekte �bergeben und serialisiert. Dies ergibt einen bin�ren
Blob\footnote{Binary large object}, der als Dateiupload an den Server �bertragen wird, der diesen Blob dort wieder
deserialisiert um das urspr�ngliche Java-Objekt zu erhalten. Abh�ngig von der auf dem
Spielserver aufgerufenen URL, wird dieses Java-Objekt auf dem Server einem bestimmten
Teil der Programmlogik �bergeben, die dann damit arbeitet. Eventuelle
R�ckgabewerte der Programmlogik werden nach dem gleichen Verfahren durch Serialisierung von Objekten
in bin�re Blobs umgewandelt, als Dateidownload dem Spielapplet �bermittelt und dort
wieder in ein Java-Objekt deserialisiert. Aus Sicherheitsgr�nden werden auf dem Server
auftretende Fehler nicht an das Spiel �bergeben und nur in ein Logfile auf dem Server
geschrieben; so wird das versehentliche Anzeigen bspw. von Passw�rtern oder der
Datenbankstruktur auf der Clientseite vermieden.

\subsection{Java3D}
Flowgame ist eine Java3D\footnote{Einf�hrung unter
\url{http://java.sun.com/developer/onlineTraining/java3d/}}-Anwendung, die als
Java-Applet im Browser des Spielers (also auf dem Client) l�uft. Das Universum bei Flowgame enth�lt vier unterschiedliche Typen von dreidimensionalen Objekten. Einen Tunnel, durch den das Raumschiff des Spielers fliegt,
wobei es den entgegenkommenden Asteroiden ausweichen und Diamanten aufsammeln
soll.

Alle Klassen der 3D-Engine befinden sich im Package \texttt{client.engine}.

W�hrend dem Start des Applets wird in \texttt{GameApplet.java} (Zeile 79) der
Szenengraph f�r das Spiel erstellt. Dort wird ein \texttt{Game3D} Objekt
erzeugt, dass die einzelnen 3D-Objekte erstellt und in einen Szenengraph
einh�ngt. In \texttt{Game3D.java} wird in Zeile 151 zun�chst das Universum
selbst instanziiert. Der Methodenaufruf in Zeile 162 erstellt die restlichen Objekte und bindet sie ein. Der Tunnel wird dabei (in \texttt{Tunnel.java}) mittels
Javacode als zylinderf�rmige \texttt{Shape3D} erzeugt, w�hrend die anderen
Objekte aus externen Objektmodelldateien eingelesen werden. Diese Objektmodelldateien befinden sich im
Ressourcen Ordner (\texttt{src/res/}).

Schiffsbewegung, Steuerung und Kollisionserkennung werden mit Behaviors realisiert.
Behaviors dienen bei Java3D als Basis f�r Interaktion und Animation. Viele dieser Aktionen
m�ssen in jedem Frame\footnote{Animierte Sequenzen in einer dreidimensionalen Umgebung werden von der Grafikhardware Bild f�r Bild berechnet. Eines dieser Einzelbilder wird Frame genannt. Je leistungsf�higer die vorhandene (Grafik)Hardware ist, desto mehr Bilder k�nnen pro Sekunde berechnet werden. Zur fl�ssigen Darstellung von Bewegung sollten stets mindestens 30 Frames/Sekunde berechnet werden k�nnen.} ausgef�hrt oder aufgerufen werden. Daher gibt es eine abstrakte \texttt{RepeatingBehavior} Klasse, die beim Neuzeichnen jedes Frames aufgerufen wird und den Zeitabstand zwischen den Frames misst. Letzteres erm�glicht eine Steuerung der Geschwindigkeit unabh�ngig von der Framerate. Gleichzeitig implementiert diese abstrakte Klasse das Interface \texttt{GameListener}, mit dem auf Ereignisse im
Spielablauf reagiert werden kann.

\texttt{ShipNavigationBehavior} dient zur Bewegung des Schiffes in xy-Richtung,
also nach links/rechts und oben/unten. Die z-Achse entspricht bei Java3D der Tiefeninformation, Bewegung
in dieser Richtung wird mit der \texttt{ForwardBehavior} realisiert, wobei die
Geschwindigkeit der Bewegung wiederum von der \texttt{SpeedChangeBehavior}
gesteuert wird. �ber diese Behavior wird der Schwierigkeitsgrad reguliert. Die
Kamera folgt dem Schiff dabei in festem Abstand, es sieht also so aus, als ob die Kollisionsobjekte (Diamanten, Asteroiden) auf den Spieler zukommen. Die
\texttt{CreateCollidablesBehavior} stellt sicher, dass vor dem Schiff immer wieder neue Kollisionsobjekte erzeugt werden.

Da die bei Java3D eingebauten M�glichkeiten zur Kollisionserkennung vor allem bei
h�heren Bewegungsgeschwindigkeiten des Schiffes versagen, wurde auch eine eigene
(einfache) Kollisionserkennung in Form der \texttt{CollisionBehavior}
implementiert. Der (unendlich lange) Tunnel bewegt sich selbst nicht, die Illusion der Bewegung wird �ber eine
Texturtransformation gesteuert. Die \texttt{TextureTransformBehavior} sorgt
daf�r, dass die Geschwindigkeit der Textur zu der des Schiffes passt.

Die Behaviors werden bei der Erzeugung des 3D-Universums an die jeweils
betroffenen Objekte gebunden.

\subsection{Facebook-Anbindung}
Zur Anbindung an Facebook wird die Bibliothek \code{facebook-java-api}\footnote{\url{http://code.google.com/p/facebook-java-api/}} verwendet, mit der Informationen �ber den Spieler und die Bilder seiner Freunde f�r den Social High\-score abgerufen werden. Die Facebook-Anfragen werden direkt vom Spiel-Applet gestellt und �ber den Spiel-Server an die Facebook-API weitergeleitet. Dieser Umweg �ber den Server ist n�tig, da ein Applet wegen der Same Origin Policy nur zum Ursprungsserver und nicht direkt zu den Facebook-Servern eine Verbindung aufbauen darf.

\section{Entwicklungsumgebung}
Die Entwicklungsumgebung beinhaltet alle Programme, die zum entwerfen,
programmieren, kompilieren und testweisen Ausf�hren des Spiels und der Verwaltung des
Entwicklungsprozesses n�tig sind.

F�r eine zentrale Verwaltung des gesamten Codes und aller weiteren Bestandteile des
Spiels (Grafiken, Musik, Sounds) wurde auf Google Code ein Projekt angelegt\footnote{\url{http://code.google.com/p/flowgame}}, dass neben dem Versionskontrollsystem Subversion auch ein Issue-Tracking f�r das Verfolgen und Verwalten von Fehlern und �nderungsw�nschen bietet.

Als IDE\footnote{Integrated Development Environment -- integrierte
Entwicklungsumgebung} wird Eclipse\footnote{\url{http://www.eclipse.org}} in der EE\footnote{Enterprise Edition,
erm�glicht unter anderem das Entwickeln von Webanwendungen}-Variante mit
diversen Erweiterungen verwendet:
Subclipse\footnote{\url{http://subclipse.tigris.org/}} stellt die Anbindung an
das von Google Code zur Verf�gung gestellten
Versionkontrollsystem bereit, FindBugs\footnote{statisches Quellcode Analysewerkzeug -- \url{http://findbugs.sourceforge.net}} und PMD\footnote{statisches Quellcode Analysewerkzeug -- \url{http://pmd.sourceforge.net}} analysieren den Programmcode auf h�ufig auftretende
Programmierfehler.\newline Um das Spiel vollst�ndig lokal auszuf�hren, ist ein
lokal installierter MySQL\footnote{\url{http://mysql.com}}-Daten\-bankserver notwendig. So k�nnen �nderungen ohne Beeinflussung des auf Facebook laufenden Spiels getestet werden.

Um jederzeit eine lauff�hige Version des neuesten Entwicklungsstands zu haben, wird
Hudson als CI\footnote{Continuous Integration, das durchg�ngige Kompilieren und Auswerten von Programmcode\\ \url{http://hudson-ci.org}}-Server verwendet, der zum einen die o.g. Werkzeuge FindBugs
und PMD nochmals zentral ausf�hrt und dazu Statistiken erzeugt und zum anderen das
Deployment des Spiels auf den Facebook bekannten Spielserver vollst�ndig automatisiert
und reproduzierbar durchf�hren kann. Insgesamt verbessert der CI-Server damit die
Code-Qualit�t und reduziert etwaige Fehlhandlungen beim Deployment neuer Versionen des
Spiels, wodurch weniger Fehler im Spiel selbst auftreten.

\section{Herausforderungen bei der Umsetzung}

Bei der Umsetzung der Anforderungen mussten verschiedene Herausforderungen
gemeistert werden, die teils technischer teils projektorganisatorischer Natur
waren.

\subsection{Technische Herausforderungen}

Trotz des Slogans ``Write once, run anywhere'' entstand durch die vielen verschiedenen Plattformen, auf denen das Spiel am Ende laufen sollte eine enormer Test- und Anpassungsaufwand, der zu Beginn untersch�tzt wurde. So verhielten sich die vielf�ltigen Kombinationen aus Java-Plugin, Browser und Betriebssystem sehr unterschiedlich; insbesondere Mac OS X bereitete hier Probleme, da hier eine nicht austauschbare veraltete Version von Java3D in das Betriebssystem integriert war, die bedeutend langsamer und fehleranf�lliger als die zur Verwendung vorgesehene aktuelle Fassung war. Teilweise verweigerte auch Java3D selbst auf eigentlich f�higer Hardware den Dienst, was dazu f�hrte, dass das Spiel sich gar nicht erst starten lie�. Gr��tes Problem im Betrieb waren die stetigen �nderungen von Facebook an ihren Schnittstellen, die  diverse Male Funktionen des Spiels beeinflussten; am deutlichsten wurde dies zum Ende der Datenerfassung, als das Spiel kurzfristig gar nicht mehr zu erreichen war. Facebook hatte den Mechanismus unangek�ndigt so ver�ndert, dass eine Umkonfiguration auf dem Spielserver notwendig war, um das Spiel wieder auf Facebook zug�nglich zu machen.


\subsection{Herausforderungen im Projektmanagement}

Durch die lange Laufzeit des Projekts kam es immer wieder zu Verz�gerungen bei der Fertigstellung von Teilschritten, weil �ber Vorlesungszeit und Semesterferien die Verf�gbarkeit von Teammitgliedern durch Vorlesungen, Klausuren und Privates teilweise stark schwankte. Ebenso wurde anf�nglich das Anforderungsmanagement nicht stringent genug durchgef�hrt, was die Erstellung und Abnahme einzelner Teilschritte komplizierte, da hier die Erwartungen auseinandergingen. Etwa zur zweiten H�lfte der Projektlaufzeit wurde dann vermehrt das von Google Code zur Verf�gung gestellte Issue Tracking sowohl f�r das Management von Nacharbeiten als auch neuer Anforderungen verwendet. Dies f�hrte zum einen zu deutlich besser dokumentierten Anforderungen und erm�glichte zum anderen eine verbesserte Kommunikation zu einzelnen offenen Punkten. Dadurch erh�hte sich die Geschwindigkeit, mit der �nderungen eingearbeitet werden konnten. Im Nachhinein h�tte von Anfang an das Issue Tracking f�r alle Anforderungen und Fehler verwendet werden sollen, um eine durchg�ngige Dokumentation und Fortschrittskontrolle zu gew�hrleisten.

%\usepackage{graphics} is needed for \includegraphics
\begin{figure}[htp]
\begin{center}
  \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{Gesamtablauf}
  \caption[Gesamtablauf]{Gesamtablauf}
  \label{fig:Gesamtablauf}
\end{center}
\end{figure} 

%\include{acronyms}
%\clearpage

\clearpage
\addcontentsline{toc}{section}{Abbildungen}
\listoffigures
  
\clearpage
\addcontentsline{toc}{section}{Literatur}
\bibliography{literatur}{}
\bibliographystyle{alphadin}

\end{document}
